https://docs.google.com/document/d/1ogBLRmkPsgtSMomh6rCfBjicti8r8Td_a7gv0rTrUDg/edit?tab=t.0 

A from scratch 3d renderer that utilizes the entire 3d graphics pipeline like rotation matrix arithmetic, near plane line clipping, perspective projection, and viewport point transformation. 

The Simplicity of 3D Graphics

	I, like many people, have played 3D video games for as long as I can remember. The fact that I could see into a three-dimensional world on my monitor, a two-dimensional plane, always seemed like magic to me. That is, until I stumbled across the Tsoding video on Youtube, “One Formula that Demystifies 3D Graphics”, where Tsoding programs a very simple 3D renderer from scratch in JavaScript which is capable of rendering, rotating, translating, and rendering a cube to the screen. This fascinated me so greatly that I built my own 3D renderer and added near plane line clipping among other algorithms, stretching the project in ways that allowed me to make my own new discoveries.
3D Rendering Process
All rotation and translation is controlled by the user.
Rotate the object in local space so that it is oriented in the correct direction.
Translate the object from its origin. This comes after the local space rotation since the rotation matrix is only capable of rotating a point around the origin. If the rotations were done post-translation, the camera would appear to rotate rather than the object itself. It helps me to imagine pre-translation rotations as the earth spinning around its own axis while post-translation rotations can be thought of as the earth orbiting the sun.
Add camera rotations to the object to simulate the viewers changing perspective. As previously described, these rotations are done now since the object is now translated away from the origin, allowing it to be rotated around said origin.
Use near plane line clipping so that line segments that exist partially in front of the camera and partially behind that camera are “clipped” to the “near plane” to remove the risk of  “artifacts” when the object is rendered. Artifacts are just any unintended rendering of pixels on the screen. We describe a line as clipped since although it maintains its direction in the 3D space, its length is shortened so that no portion of it exists behind the near plane. The near plane is just a 2D plane that has a z index very close to zero (usually something like 0.001). The near plane is close to but not zero in order to avoid zero division errors on points with z value of zero, as displayed in a later formula.
Use perspective projection for each Vector3 into Vector2, creating the illusion of a 3D object on a 2D display. All you have to do for this step is to divide a Vector3’s x and y by z. For example, consider a Vector3 with (x: 1, y: 0.5, z: 2). Now divide x and y by z and discard z to yield a new Vector2 with (x: 0.5, y: 0.25). This is where the magic happens. If you consider z as an arbitrary value quantifying the distance of a Vector3 from the screen, it makes sense why points further from the screen will get smaller and appear closer to the origin.closer to the origin center relative to the other objects in your FOV. A simple test one can run to observe this phenomenon goes as follows: Hold your hand over your right eye and watch as you slowly extend your arm out in front of you. As your hand extends away from you (z value increases), it appears closer and closer to the origin (center) of your field of view relative to other objects.
Transform the point into viewport coordinates so that it exists on the screen. All algorithms up until this point rely on the point being between the x interval [-1, 1] and y interval [-1, 1]. We now need to transform the point from an arbitrary point that exists on said interval to a point that exists on the x interval [0, SCREEN_WIDTH] and y interval [0, SCREEN_HEIGHT].
